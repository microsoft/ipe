{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Integrity Policy Enforcement (IPE) Overview IPE is a Linux Security Module, which allows for a configurable policy to enforce integrity requirements on the whole system. It attempts to solve the issue of code integrity: that any code being executed (or files being read), are identical to the version that was built by a trusted source. Simply stated, IPE helps the owner of a system ensure that only code they have authorized is allowed to execute. There are multiple implementations already within the Linux kernel that solve some measure of integrity verification. For instance, device-mapper verity, which ensures integrity for a block device, and fs-verity which is a system that ensures integrity for a filesystem. What these implementations lack is a measure of run-time verification that binaries are sourced from these locations. IPE aims to address this gap. IPE is separated between two major components: A configurable policy, provided by the LSM (\"IPE Core\"), and deterministic attributes provided by the kernel to evaluate files against, (\"IPE Properties\"). What is the value of code integrity? Code integrity is identified as one of the most effective security mitigations for modern systems. With Private Key Infrastructure and code signing you can effectively control the execution of all binaries on a system to be restricted to a known subset. This eliminates attacks such as: Linker hijacking (LD_PRELOAD, LD_AUDIT, DLL Injection) Binary rewriting Malicious binary execution / loading As a result, most of the low effort, high value attacks are mitigated completely. Use Cases IPE is designed for use in devices with a specific purpose like embedded systems (e.g. network firewall device in a data center), where all software and configuration is built and provisioned by the owner. Ideally, a system which leverages IPE is not intended for general purpose computing and does not utilize any software or configuration built by a third party. An ideal system to leverage IPE has both mutable and immutable components, however, all binary executable code is immutable. For the highest level of security, platform firmware should verify the the kernel and optionally the root filesystem (e.g. via U-Boot verified boot). This allows the entire system to be integrity verified. Known Gaps IPE cannot verify the integrity of anonymous executable memory, such as the trampolines created by gcc closures and libffi, or JIT'd code. Unfortunately, as this is dynamically generated code, there is no way for IPE to detect that this code has not been tampered with in transition from where it was built, to where it is running. As a result, IPE is incapable of tackling this problem for dynamically generated code. IPE cannot verify the integrity of interpreted languages' programs when these scripts invoked via <interpreter> <file> . This is because the way interpreters execute these files, the scripts themselves are not evaluated as executable code through one of IPE's hooks. Interpreters can be enlightened to the usage of IPE by trying to mmap a file into executable memory (+X), after opening the file and responding to the error code appropriately. This also applies to included files, or high value files, such as configuration files of critical system components. This specific gap is planned on being addressed within IPE.","title":"Home"},{"location":"#integrity-policy-enforcement-ipe","text":"","title":"Integrity Policy Enforcement (IPE)"},{"location":"#overview","text":"IPE is a Linux Security Module, which allows for a configurable policy to enforce integrity requirements on the whole system. It attempts to solve the issue of code integrity: that any code being executed (or files being read), are identical to the version that was built by a trusted source. Simply stated, IPE helps the owner of a system ensure that only code they have authorized is allowed to execute. There are multiple implementations already within the Linux kernel that solve some measure of integrity verification. For instance, device-mapper verity, which ensures integrity for a block device, and fs-verity which is a system that ensures integrity for a filesystem. What these implementations lack is a measure of run-time verification that binaries are sourced from these locations. IPE aims to address this gap. IPE is separated between two major components: A configurable policy, provided by the LSM (\"IPE Core\"), and deterministic attributes provided by the kernel to evaluate files against, (\"IPE Properties\").","title":"Overview"},{"location":"#what-is-the-value-of-code-integrity","text":"Code integrity is identified as one of the most effective security mitigations for modern systems. With Private Key Infrastructure and code signing you can effectively control the execution of all binaries on a system to be restricted to a known subset. This eliminates attacks such as: Linker hijacking (LD_PRELOAD, LD_AUDIT, DLL Injection) Binary rewriting Malicious binary execution / loading As a result, most of the low effort, high value attacks are mitigated completely.","title":"What is the value of code integrity?"},{"location":"#use-cases","text":"IPE is designed for use in devices with a specific purpose like embedded systems (e.g. network firewall device in a data center), where all software and configuration is built and provisioned by the owner. Ideally, a system which leverages IPE is not intended for general purpose computing and does not utilize any software or configuration built by a third party. An ideal system to leverage IPE has both mutable and immutable components, however, all binary executable code is immutable. For the highest level of security, platform firmware should verify the the kernel and optionally the root filesystem (e.g. via U-Boot verified boot). This allows the entire system to be integrity verified.","title":"Use Cases"},{"location":"#known-gaps","text":"IPE cannot verify the integrity of anonymous executable memory, such as the trampolines created by gcc closures and libffi, or JIT'd code. Unfortunately, as this is dynamically generated code, there is no way for IPE to detect that this code has not been tampered with in transition from where it was built, to where it is running. As a result, IPE is incapable of tackling this problem for dynamically generated code. IPE cannot verify the integrity of interpreted languages' programs when these scripts invoked via <interpreter> <file> . This is because the way interpreters execute these files, the scripts themselves are not evaluated as executable code through one of IPE's hooks. Interpreters can be enlightened to the usage of IPE by trying to mmap a file into executable memory (+X), after opening the file and responding to the error code appropriately. This also applies to included files, or high value files, such as configuration files of critical system components. This specific gap is planned on being addressed within IPE.","title":"Known Gaps"},{"location":"attribution/","text":"Attribution This page serves as a way to pay homage to the tools and resources utilized for the development of IPE and it's supporting features. Mkdocs This package is used to generate these documentation pages. License MkDocs License (BSD) Copyright \u00a9 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"Attribution"},{"location":"attribution/#attribution","text":"This page serves as a way to pay homage to the tools and resources utilized for the development of IPE and it's supporting features.","title":"Attribution"},{"location":"attribution/#mkdocs","text":"This package is used to generate these documentation pages.","title":"Mkdocs"},{"location":"attribution/#license","text":"MkDocs License (BSD) Copyright \u00a9 2014, Tom Christie. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"faq/","text":"FAQ What's the difference between other LSMs which provide integrity verification (i.e. IMA)? IPE differs from other LSMs which provide integrity checking, as it has no dependency on the filesystem metadata itself. The attributes that IPE checks are deterministic properties that exist solely in the kernel. Additionally, IPE provides no additional mechanisms of verifying these files (e.g. IMA Signatures) - all of the attributes of verifying files are existing features within the kernel. Additionally, IPE is completely restricted to integrity. It offers no measurement or attestation features, which IMA addresses. Where can I find the code for IPE? The IPE LSM code has been submitted for review to the Linux kernel project: https://lkml.kernel.org/lkml/20200406221439.1469862-4-deven.desai@linux.microsoft.com/T/#mfe85eb38a5596999f0bb8aa9dda3bee4e71eaa60","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#whats-the-difference-between-other-lsms-which-provide-integrity-verification-ie-ima","text":"IPE differs from other LSMs which provide integrity checking, as it has no dependency on the filesystem metadata itself. The attributes that IPE checks are deterministic properties that exist solely in the kernel. Additionally, IPE provides no additional mechanisms of verifying these files (e.g. IMA Signatures) - all of the attributes of verifying files are existing features within the kernel. Additionally, IPE is completely restricted to integrity. It offers no measurement or attestation features, which IMA addresses.","title":"What's the difference between other LSMs which provide integrity verification (i.e. IMA)?"},{"location":"faq/#where-can-i-find-the-code-for-ipe","text":"The IPE LSM code has been submitted for review to the Linux kernel project: https://lkml.kernel.org/lkml/20200406221439.1469862-4-deven.desai@linux.microsoft.com/T/#mfe85eb38a5596999f0bb8aa9dda3bee4e71eaa60","title":"Where can I find the code for IPE?"},{"location":"license/","text":"Licensing for IPE Per compliance with the Linux kernel's source code license, the kernel code of IPE is licensed under the GPLv2 License. The documentation, test suite, and tools contained within this repository are licensed under the following license: License Copyright (c) Microsoft All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#licensing-for-ipe","text":"Per compliance with the Linux kernel's source code license, the kernel code of IPE is licensed under the GPLv2 License. The documentation, test suite, and tools contained within this repository are licensed under the following license:","title":"Licensing for IPE"},{"location":"license/#license","text":"Copyright (c) Microsoft All rights reserved. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"policy/","text":"IPE Policy The most essential part of IPE is its customizable policy which allows users to specify the rules that the LSM should enforce for different operations. This policy is designed to be both forward compatible and backwards compatible. There is one required line, at the top of the policy, indicating the policy name, and the policy version, for instance: policy_name=\"Ex Policy\" policy_version=0.0.0 The policy name is a unique key identifying this policy in a human readable name. This is used to create nodes under securityfs as well as uniquely identify policies to deploy new policies vs update existing policies. The policy version indicates the current version of the policy (NOT the policy syntax version). This is used to prevent roll-back of policy to potentially insecure previous versions of the policy. The next portion of IPE policy, are rules. Rules are formed by key=value pairs, known as properties. IPE rules require two properties: \"action\", which determines what IPE does when it encounters a match against the rule, and \"op\", which determines when that rule should be evaluated. Thus, a minimal rule is: op=EXECUTE action=ALLOW This example will allow any execution. Additional properties are used to restrict attributes about the files being evaluated. These properties are intended to be deterministic attributes that are resident in the kernel. Order does not matter for the rule's properties - they can be listed in any order, however it is encouraged to have the \"op\" property be first, and the \"action\" property be last for readability. Rules are evaluated top-to-bottom. As a result, any revocation rules, or denies should be placed early in the file to ensure that these rules are evaluated before as rule with \"action=ALLOW\" is hit. IPE policy is designed to be forward compatible and backwards compatible, thus any failure to parse a rule will result in the line being ignored, and a warning being emitted. If backwards compatibility is not required, the kernel command line parameter and sysctl, ipe.strict_parse can be enabled, which will cause these warnings to be fatal. IPE policy supports comments. The character '#' will function as a comment, ignoring all characters to the right of '#' until the newline. The default behavior of IPE evaluations can also be expressed in policy, through the DEFAULT statement. This can be done at a global level, or a per-operation level: # Global DEFAULT action=ALLOW # Operation Specific DEFAULT op=EXECUTE action=ALLOW If a global default is unset, and a specific operation default is not set for an IPE operation, it will assume that the default action should be ALLOW . This is to preserve compatibility between policies and the LSM. Early user-mode protection With configurable policy-based LSMs, there's several issues with enforcing the configurable policies at startup, around reading and parsing the policy: The kernel should not read files from userland, so directly reading the policy file is prohibited. The kernel command line has a character limit, and one kernel module should not reserve the entire character limit for its own configuration. There are various boot loaders in the kernel ecosystem, so handing off a memory block would be costly to maintain. As a result, IPE has addressed this problem through a concept of a \"boot policy\". A boot policy is a minimal policy, compiled into the kernel. This policy is intended to get the system to a state where userland is setup and ready to receive commands, at which point a more complex policy (\"user policies\") can be deployed via securityfs. The boot policy can be specified via the Kconfig, SECURITY_IPE_BOOT_POLICY , which accepts a path to a plain-text version of the IPE policy to apply. This policy will be compiled into the kernel. If not specified, IPE will be disabled until a policy is deployed through securityfs, and activated through sysfs. Modes IPE, similar to SELinux, supports two modes of operation: permissive and enforce. Permissive mode performs the same checks as enforce mode, and logs policy violations, but will not enforce the policy. This allows users to test policies before enforcing them. The default mode is enforce, and can be changed via the kernel command line parameter ipe.enforce=(0|1) , or the sysctl ipe.enforce=(0|1) . The ability to switch modes can be compiled out of the LSM via setting the Kconfig CONFIG_SECURITY_IPE_PERMISSIVE_SWITCH to N.","title":"Overview"},{"location":"policy/#ipe-policy","text":"The most essential part of IPE is its customizable policy which allows users to specify the rules that the LSM should enforce for different operations. This policy is designed to be both forward compatible and backwards compatible. There is one required line, at the top of the policy, indicating the policy name, and the policy version, for instance: policy_name=\"Ex Policy\" policy_version=0.0.0 The policy name is a unique key identifying this policy in a human readable name. This is used to create nodes under securityfs as well as uniquely identify policies to deploy new policies vs update existing policies. The policy version indicates the current version of the policy (NOT the policy syntax version). This is used to prevent roll-back of policy to potentially insecure previous versions of the policy. The next portion of IPE policy, are rules. Rules are formed by key=value pairs, known as properties. IPE rules require two properties: \"action\", which determines what IPE does when it encounters a match against the rule, and \"op\", which determines when that rule should be evaluated. Thus, a minimal rule is: op=EXECUTE action=ALLOW This example will allow any execution. Additional properties are used to restrict attributes about the files being evaluated. These properties are intended to be deterministic attributes that are resident in the kernel. Order does not matter for the rule's properties - they can be listed in any order, however it is encouraged to have the \"op\" property be first, and the \"action\" property be last for readability. Rules are evaluated top-to-bottom. As a result, any revocation rules, or denies should be placed early in the file to ensure that these rules are evaluated before as rule with \"action=ALLOW\" is hit. IPE policy is designed to be forward compatible and backwards compatible, thus any failure to parse a rule will result in the line being ignored, and a warning being emitted. If backwards compatibility is not required, the kernel command line parameter and sysctl, ipe.strict_parse can be enabled, which will cause these warnings to be fatal. IPE policy supports comments. The character '#' will function as a comment, ignoring all characters to the right of '#' until the newline. The default behavior of IPE evaluations can also be expressed in policy, through the DEFAULT statement. This can be done at a global level, or a per-operation level: # Global DEFAULT action=ALLOW # Operation Specific DEFAULT op=EXECUTE action=ALLOW If a global default is unset, and a specific operation default is not set for an IPE operation, it will assume that the default action should be ALLOW . This is to preserve compatibility between policies and the LSM.","title":"IPE Policy"},{"location":"policy/#early-user-mode-protection","text":"With configurable policy-based LSMs, there's several issues with enforcing the configurable policies at startup, around reading and parsing the policy: The kernel should not read files from userland, so directly reading the policy file is prohibited. The kernel command line has a character limit, and one kernel module should not reserve the entire character limit for its own configuration. There are various boot loaders in the kernel ecosystem, so handing off a memory block would be costly to maintain. As a result, IPE has addressed this problem through a concept of a \"boot policy\". A boot policy is a minimal policy, compiled into the kernel. This policy is intended to get the system to a state where userland is setup and ready to receive commands, at which point a more complex policy (\"user policies\") can be deployed via securityfs. The boot policy can be specified via the Kconfig, SECURITY_IPE_BOOT_POLICY , which accepts a path to a plain-text version of the IPE policy to apply. This policy will be compiled into the kernel. If not specified, IPE will be disabled until a policy is deployed through securityfs, and activated through sysfs.","title":"Early user-mode protection"},{"location":"policy/#modes","text":"IPE, similar to SELinux, supports two modes of operation: permissive and enforce. Permissive mode performs the same checks as enforce mode, and logs policy violations, but will not enforce the policy. This allows users to test policies before enforcing them. The default mode is enforce, and can be changed via the kernel command line parameter ipe.enforce=(0|1) , or the sysctl ipe.enforce=(0|1) . The ability to switch modes can be compiled out of the LSM via setting the Kconfig CONFIG_SECURITY_IPE_PERMISSIVE_SWITCH to N.","title":"Modes"},{"location":"policy/deployment/","text":"Deploying Policies User policies are policies that are deployed from userland, through securityfs. These policies are signed to enforce some level of authorization of the policies (prohibiting an attacker from gaining root, and deploying an \"allow all\" policy), through the PKCS#7 enveloped data format. These policies must be signed by a certificate that chains to the SYSTEM_TRUSTED_KEYRING . Through openssl, the signing can be done via: openssl smime -sign -in \"$MY_POLICY\" -signer \"$MY_CERTIFICATE\" \\ -inkey \"$MY_PRIVATE_KEY\" -binary -outform der -noattr -nodetach \\ -out \"$MY_POLICY.p7s\" Deploying the policies is done through securityfs, through the new_policy node. To deploy a policy, simply cat the file into the securityfs node: cat \"$MY_POLICY.p7s\" > /sys/kernel/security/ipe/new_policy Upon success, this will create one subdirectory under /sys/kernel/security/ipe/policies/ . The subdirectory will be the policy_name field of the policy deployed, so for the example above, the directory will be /sys/kernel/security/ipe/policies/Ex\\ Policy . Within this directory, there will be two files: raw and content . The raw file is rw, reading will provide the raw PKCS#7 data that was provided to the kernel, representing the policy. Writing, will deploy an in-place policy update - if this policy is the currently running policy, the new updated policy will replace it immediately upon success. The content file is read only. Reading will provide the PKCS#7 inner content of the policy, which will be the plain text policy. Similarly, the cat command above will result in an error upon syntactically invalid or untrusted policies. It will also error if a policy already exists with the same policy_name . The write to the raw node will error upon syntactically invalid, untrusted policies, or if the payload fails the version check. The write will also fail if the policy_name in the payload does not match the existing policy. Activating Policies Deploying these policies will not cause IPE to start enforcing this policy. Once deployment is successful, a policy can be marked as active, via the sysctl, ipe.active_policy . IPE will enforce whatever policy is marked as active. For our example, we can activate the Ex Policy via: sysctl ipe.active_policy=\"Ex Policy\" At which point, Ex Policy will now be the enforced policy on the system. Deleting Policies IPE also provides a way to delete policies. This can be done via the del_policy securityfs node, /sys/kernel/security/ipe/del_policy . Writing the policy_name of the policy to be deleted will delete that node: echo -n \"$MY_POLICY_NAME\" > /sys/kernel/security/ipe/del_policy There are two requirements to delete policies: The policy being deleted must not be the active policy. The policy being deleted must not be the boot policy. NOTE: It's important to know above that the \"echo\" command will add a newline to the end of the input, and this will be considered as part of the filename. You can remove the newline via the -n parameter.","title":"Deploying Policies"},{"location":"policy/deployment/#deploying-policies","text":"User policies are policies that are deployed from userland, through securityfs. These policies are signed to enforce some level of authorization of the policies (prohibiting an attacker from gaining root, and deploying an \"allow all\" policy), through the PKCS#7 enveloped data format. These policies must be signed by a certificate that chains to the SYSTEM_TRUSTED_KEYRING . Through openssl, the signing can be done via: openssl smime -sign -in \"$MY_POLICY\" -signer \"$MY_CERTIFICATE\" \\ -inkey \"$MY_PRIVATE_KEY\" -binary -outform der -noattr -nodetach \\ -out \"$MY_POLICY.p7s\" Deploying the policies is done through securityfs, through the new_policy node. To deploy a policy, simply cat the file into the securityfs node: cat \"$MY_POLICY.p7s\" > /sys/kernel/security/ipe/new_policy Upon success, this will create one subdirectory under /sys/kernel/security/ipe/policies/ . The subdirectory will be the policy_name field of the policy deployed, so for the example above, the directory will be /sys/kernel/security/ipe/policies/Ex\\ Policy . Within this directory, there will be two files: raw and content . The raw file is rw, reading will provide the raw PKCS#7 data that was provided to the kernel, representing the policy. Writing, will deploy an in-place policy update - if this policy is the currently running policy, the new updated policy will replace it immediately upon success. The content file is read only. Reading will provide the PKCS#7 inner content of the policy, which will be the plain text policy. Similarly, the cat command above will result in an error upon syntactically invalid or untrusted policies. It will also error if a policy already exists with the same policy_name . The write to the raw node will error upon syntactically invalid, untrusted policies, or if the payload fails the version check. The write will also fail if the policy_name in the payload does not match the existing policy.","title":"Deploying Policies"},{"location":"policy/deployment/#activating-policies","text":"Deploying these policies will not cause IPE to start enforcing this policy. Once deployment is successful, a policy can be marked as active, via the sysctl, ipe.active_policy . IPE will enforce whatever policy is marked as active. For our example, we can activate the Ex Policy via: sysctl ipe.active_policy=\"Ex Policy\" At which point, Ex Policy will now be the enforced policy on the system.","title":"Activating Policies"},{"location":"policy/deployment/#deleting-policies","text":"IPE also provides a way to delete policies. This can be done via the del_policy securityfs node, /sys/kernel/security/ipe/del_policy . Writing the policy_name of the policy to be deleted will delete that node: echo -n \"$MY_POLICY_NAME\" > /sys/kernel/security/ipe/del_policy There are two requirements to delete policies: The policy being deleted must not be the active policy. The policy being deleted must not be the boot policy. NOTE: It's important to know above that the \"echo\" command will add a newline to the end of the input, and this will be considered as part of the filename. You can remove the newline via the -n parameter.","title":"Deleting Policies"},{"location":"policy/events/","text":"Audit Events IPE will emit a several forms of messages to the audit channel. This section provides various information about these events and the descriptions of the fields that are emitted by these events to help with analysis of audit logs. Policy Load / Staging AUDIT1808 IPE policy_name=\"AllowAll\" policy_version=0.0.0 sha1=776FA5945C012EDDFC0866D7E3DE883CC0B67930 This event is emitted when a policy is loaded via $SECURITYFS/ipe/new_policy or $SECURITYFS/ipe/policies/<policy_name>/raw . It is emitted to the audit channel, and can be used to provide a record of what policies were loaded on the system. Field Description policy_name The policy_name field of the policy policy_version The policy_version triple parsed from the policy 1 sha1 A SHA128 flat hash of the entire policy. Can be used to identify a policy. Policy Activation / Enablement AUDIT1809 IPE policy_name=\"AllowAll\" policy_version=0.0.0 This event is emitted when a policy is activated via sysctl ipe.active_policy or when a policy is activated in place via $SECURITYFS/ipe/policies/<policy_name>/raw . It is emitted to the audit channel, and can be used to provide a record of when policies were made active. Field Description policy_name The policy_name field of the policy policy_version The policy_version triple parsed from the policy 1 IPE Mode Switch AUDIT1811 IPE mode=enforce AUDIT1811 IPE mode=permissive This event is emitted when the IPE's mode of operation is changed through the sysctl ipe.enforce . It is emitted to the audit channel, additionally, this event is emitted early during system boot to the kernel channel (audit is not emitted) to identify what mode IPE is started in. Field Description mode The mode that IPE is set to. Can be either: enforce or permissive . See the modes documentation for more information. IPE Binary Event AUDIT1810 IPE ctx_pid=297 ctx_op=EXECUTE ctx_hook=EXEC ctx_comm=\"sysctl\" ctx_audit_pathname=\"/usr/lib/libc-2.30.so\" ctx_ino=135442 ctx_dev=vda prop_boot_verified=TRUE prop_dmverity_roothash=NULL prop_dmverity_signature=FALSE rule=\"DEFAULT action=DENY\" This event is emitted when IPE evaluates a binary. By default 2 , it will only be triggered on \"action=DENY\" events, or \"blocks\". This event provides a record of execution that violated policy and can be used to identify gaps within the currently deployed policy, or a system that may be under attack. Certain fields may be omitted, or replaced with ERR(%d) which identifes the error code when attempting to retrieve that value. Field Description Optional ctx_pid The process ID of the process being evaluated. No ctx_op The operation that IPE is evaluating the file under. See op . No ctx_hook The LSM hook that the file is being evaluated under. Provides a more granular description that ctx_op . No ctx_comm The effective name of the process, as evaluated by the kernel. No ctx_audit_pathname The effective absolute path to the file being evaluated. Walks past chroots and mount points. Yes ctx_ino The inode number of the file being evaluated. Yes ctx_dev The device name that the file belongs to. Yes prop_boot_verified The evaluation of the property, boot_verified . Can be ommitted if this property is not present in the kernel (not compiled in). Yes prop_dmverity_roothash The evaluation of the property, dmverity_roothash . Can be ommitted if this property is not present in the kernel (not compiled in). Yes prop_dmverity_signature The evaluation of the property, dmverity_signature . Can be ommitted if this property is not present in the kernel (not compiled in). Yes rule The plain-text approximation of the rule that was matched. No 1 A policy with 4+ version numbers will parse successfully, but only the first three will be considered as part of the version. These fields will only emit the parsed version. 2 IPE supports success auditing. When enabled, all events that pass IPE policy and are not blocked will emit an audit event. This is disabled by default, and can be enabled via the kernel command line ipe.success_audit=(0|1) or the sysctl ipe.success_audit=(0|1) . This is very noisy, as IPE will check every user-mode binary on the system, but is useful for debugging policies.","title":"Audit Events"},{"location":"policy/events/#audit-events","text":"IPE will emit a several forms of messages to the audit channel. This section provides various information about these events and the descriptions of the fields that are emitted by these events to help with analysis of audit logs.","title":"Audit Events"},{"location":"policy/events/#policy-load-staging","text":"AUDIT1808 IPE policy_name=\"AllowAll\" policy_version=0.0.0 sha1=776FA5945C012EDDFC0866D7E3DE883CC0B67930 This event is emitted when a policy is loaded via $SECURITYFS/ipe/new_policy or $SECURITYFS/ipe/policies/<policy_name>/raw . It is emitted to the audit channel, and can be used to provide a record of what policies were loaded on the system. Field Description policy_name The policy_name field of the policy policy_version The policy_version triple parsed from the policy 1 sha1 A SHA128 flat hash of the entire policy. Can be used to identify a policy.","title":"Policy Load / Staging"},{"location":"policy/events/#policy-activation-enablement","text":"AUDIT1809 IPE policy_name=\"AllowAll\" policy_version=0.0.0 This event is emitted when a policy is activated via sysctl ipe.active_policy or when a policy is activated in place via $SECURITYFS/ipe/policies/<policy_name>/raw . It is emitted to the audit channel, and can be used to provide a record of when policies were made active. Field Description policy_name The policy_name field of the policy policy_version The policy_version triple parsed from the policy 1","title":"Policy Activation / Enablement"},{"location":"policy/events/#ipe-mode-switch","text":"AUDIT1811 IPE mode=enforce AUDIT1811 IPE mode=permissive This event is emitted when the IPE's mode of operation is changed through the sysctl ipe.enforce . It is emitted to the audit channel, additionally, this event is emitted early during system boot to the kernel channel (audit is not emitted) to identify what mode IPE is started in. Field Description mode The mode that IPE is set to. Can be either: enforce or permissive . See the modes documentation for more information.","title":"IPE Mode Switch"},{"location":"policy/events/#ipe-binary-event","text":"AUDIT1810 IPE ctx_pid=297 ctx_op=EXECUTE ctx_hook=EXEC ctx_comm=\"sysctl\" ctx_audit_pathname=\"/usr/lib/libc-2.30.so\" ctx_ino=135442 ctx_dev=vda prop_boot_verified=TRUE prop_dmverity_roothash=NULL prop_dmverity_signature=FALSE rule=\"DEFAULT action=DENY\" This event is emitted when IPE evaluates a binary. By default 2 , it will only be triggered on \"action=DENY\" events, or \"blocks\". This event provides a record of execution that violated policy and can be used to identify gaps within the currently deployed policy, or a system that may be under attack. Certain fields may be omitted, or replaced with ERR(%d) which identifes the error code when attempting to retrieve that value. Field Description Optional ctx_pid The process ID of the process being evaluated. No ctx_op The operation that IPE is evaluating the file under. See op . No ctx_hook The LSM hook that the file is being evaluated under. Provides a more granular description that ctx_op . No ctx_comm The effective name of the process, as evaluated by the kernel. No ctx_audit_pathname The effective absolute path to the file being evaluated. Walks past chroots and mount points. Yes ctx_ino The inode number of the file being evaluated. Yes ctx_dev The device name that the file belongs to. Yes prop_boot_verified The evaluation of the property, boot_verified . Can be ommitted if this property is not present in the kernel (not compiled in). Yes prop_dmverity_roothash The evaluation of the property, dmverity_roothash . Can be ommitted if this property is not present in the kernel (not compiled in). Yes prop_dmverity_signature The evaluation of the property, dmverity_signature . Can be ommitted if this property is not present in the kernel (not compiled in). Yes rule The plain-text approximation of the rule that was matched. No 1 A policy with 4+ version numbers will parse successfully, but only the first three will be considered as part of the version. These fields will only emit the parsed version. 2 IPE supports success auditing. When enabled, all events that pass IPE policy and are not blocked will emit an audit event. This is disabled by default, and can be enabled via the kernel command line ipe.success_audit=(0|1) or the sysctl ipe.success_audit=(0|1) . This is very noisy, as IPE will check every user-mode binary on the system, but is useful for debugging policies.","title":"IPE Binary Event"},{"location":"policy/examples/","text":"Policy Examples Allow all policy_name=\"Allow All\" policy_version=0.0.0 DEFAULT action=ALLOW Allow only initial superblock policy_name=\"Allow All Initial SB\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE boot_verified=TRUE action=ALLOW Allow any signed dm-verity volume and the initial superblock policy_name=\"AllowSignedAndInitial\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE boot_verified=TRUE action=ALLOW op=EXECUTE dmverity_signature=TRUE action=ALLOW Prohibit execution from a specific dm-verity volume policy_name=\"AllowSignedAndInitial\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE dmverity_roothash=401fcec5944823ae12f62726e8184407a5fa9599783f030dec146938 action=DENY op=EXECUTE boot_verified=TRUE action=ALLOW op=EXECUTE dmverity_signature=TRUE action=ALLOW Allow only a specific dm-verity volume policy_name=\"AllowSignedAndInitial\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE dmverity_roothash=401fcec5944823ae12f62726e8184407a5fa9599783f030dec146938 action=ALLOW","title":"Example Policies"},{"location":"policy/examples/#policy-examples","text":"","title":"Policy Examples"},{"location":"policy/examples/#allow-all","text":"policy_name=\"Allow All\" policy_version=0.0.0 DEFAULT action=ALLOW","title":"Allow all"},{"location":"policy/examples/#allow-only-initial-superblock","text":"policy_name=\"Allow All Initial SB\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE boot_verified=TRUE action=ALLOW","title":"Allow only initial superblock"},{"location":"policy/examples/#allow-any-signed-dm-verity-volume-and-the-initial-superblock","text":"policy_name=\"AllowSignedAndInitial\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE boot_verified=TRUE action=ALLOW op=EXECUTE dmverity_signature=TRUE action=ALLOW","title":"Allow any signed dm-verity volume and the initial superblock"},{"location":"policy/examples/#prohibit-execution-from-a-specific-dm-verity-volume","text":"policy_name=\"AllowSignedAndInitial\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE dmverity_roothash=401fcec5944823ae12f62726e8184407a5fa9599783f030dec146938 action=DENY op=EXECUTE boot_verified=TRUE action=ALLOW op=EXECUTE dmverity_signature=TRUE action=ALLOW","title":"Prohibit execution from a specific dm-verity volume"},{"location":"policy/examples/#allow-only-a-specific-dm-verity-volume","text":"policy_name=\"AllowSignedAndInitial\" policy_version=0.0.0 DEFAULT action=DENY op=EXECUTE dmverity_roothash=401fcec5944823ae12f62726e8184407a5fa9599783f030dec146938 action=ALLOW","title":"Allow only a specific dm-verity volume"},{"location":"policy/properties/","text":"IPE Properties IPE properties are key=value pairs expressed in IPE policy. These properties can be used in rules within IPE policy to control the evaluation of binaries and files on the system IPE is protecting. This page contains a listing of all currently supported properties within IPE, and a description of the available values for each property. op Indicates the operation for a rule to apply to. Must be in every rule. IPE supports the following operations: EXECUTE Pertains to any file attempting to be executed, or loaded as an executable. FIRMWARE : Pertains to firmware being loaded via the firmware_class interface. This covers both the preallocated buffer and the firmware file itself. KMODULE : Pertains to loading kernel modules via modprobe or insmod . KEXEC_IMAGE : Pertains to kernel images loading via kexec . KEXEC_INITRAMFS Pertains to initrd images loading via kexec --initrd . POLICY : Controls loading IMA policies through the /sys/kernel/security/ima/policy securityfs entry. X509_CERT : Controls loading IMA certificates through the Kconfigs, CONFIG_IMA_X509_PATH and CONFIG_EVM_X509_PATH . action Determines what IPE should do when a rule matches. Must be in every rule. Can be one of: ALLOW : If the rule matches, explicitly allow the call to proceed without executing any more rules. DENY : If the rule matches, explicitly prohibit the call from proceeding without executing any more rules. boot_verified This property can be utilized for authorization of the first super-block that is mounted on the system, where IPE attempts to evaluate a file. Typically this is used for systems with an initramfs or other initial disk, where this is unmounted before the system becomes available, and is not covered by any other property. This property is enabled by the Kconfig, CONFIG_IPE_BOOT_PROP . The format of this property is: boot_verified=(TRUE|FALSE) WARNING: This property will trust any disk where the first IPE evaluation occurs. If you do not have a startup disk that is unpacked and unmounted (like initramfs), then it will automatically trust the root filesystem and potentially overauthorize the entire disk. dmverity_roothash This property can be utilized for authorization or revocation of specific dm-verity volumes, identified via root hash. It has a dependency on the DM_VERITY module. This property is enabled by the property: CONFIG_IPE_DM_VERITY_ROOTHASH . The format of this property is: dmverity_roothash=HashHexDigest dmverity_signature This property can be utilized for authorization of all dm-verity volumes that have a signed roothash that chains to the system trusted keyring. It has a dependency on the DM_VERITY_VERIFY_ROOTHASH_SIG Kconfig. This property is enabled by the Kconfig: CONFIG_IPE_DM_VERITY_SIGNATURE . The format of this property is: dmverity_signature=(TRUE|FALSE)","title":"Properties"},{"location":"policy/properties/#ipe-properties","text":"IPE properties are key=value pairs expressed in IPE policy. These properties can be used in rules within IPE policy to control the evaluation of binaries and files on the system IPE is protecting. This page contains a listing of all currently supported properties within IPE, and a description of the available values for each property.","title":"IPE Properties"},{"location":"policy/properties/#op","text":"Indicates the operation for a rule to apply to. Must be in every rule. IPE supports the following operations: EXECUTE Pertains to any file attempting to be executed, or loaded as an executable. FIRMWARE : Pertains to firmware being loaded via the firmware_class interface. This covers both the preallocated buffer and the firmware file itself. KMODULE : Pertains to loading kernel modules via modprobe or insmod . KEXEC_IMAGE : Pertains to kernel images loading via kexec . KEXEC_INITRAMFS Pertains to initrd images loading via kexec --initrd . POLICY : Controls loading IMA policies through the /sys/kernel/security/ima/policy securityfs entry. X509_CERT : Controls loading IMA certificates through the Kconfigs, CONFIG_IMA_X509_PATH and CONFIG_EVM_X509_PATH .","title":"op"},{"location":"policy/properties/#action","text":"Determines what IPE should do when a rule matches. Must be in every rule. Can be one of: ALLOW : If the rule matches, explicitly allow the call to proceed without executing any more rules. DENY : If the rule matches, explicitly prohibit the call from proceeding without executing any more rules.","title":"action"},{"location":"policy/properties/#boot_verified","text":"This property can be utilized for authorization of the first super-block that is mounted on the system, where IPE attempts to evaluate a file. Typically this is used for systems with an initramfs or other initial disk, where this is unmounted before the system becomes available, and is not covered by any other property. This property is enabled by the Kconfig, CONFIG_IPE_BOOT_PROP . The format of this property is: boot_verified=(TRUE|FALSE) WARNING: This property will trust any disk where the first IPE evaluation occurs. If you do not have a startup disk that is unpacked and unmounted (like initramfs), then it will automatically trust the root filesystem and potentially overauthorize the entire disk.","title":"boot_verified"},{"location":"policy/properties/#dmverity_roothash","text":"This property can be utilized for authorization or revocation of specific dm-verity volumes, identified via root hash. It has a dependency on the DM_VERITY module. This property is enabled by the property: CONFIG_IPE_DM_VERITY_ROOTHASH . The format of this property is: dmverity_roothash=HashHexDigest","title":"dmverity_roothash"},{"location":"policy/properties/#dmverity_signature","text":"This property can be utilized for authorization of all dm-verity volumes that have a signed roothash that chains to the system trusted keyring. It has a dependency on the DM_VERITY_VERIFY_ROOTHASH_SIG Kconfig. This property is enabled by the Kconfig: CONFIG_IPE_DM_VERITY_SIGNATURE . The format of this property is: dmverity_signature=(TRUE|FALSE)","title":"dmverity_signature"},{"location":"technical/threat-model/","text":"Threat Model The threat type addressed by IPE is tampering of executable user-land code beyond the initially booted kernel, and the initial verification of kernel modules that are loaded in userland through modprobe or insmod . Tampering violates the property of integrity. IPE's role in mitigating this threat is to verify the integrity (and authenticity) of all executable code and to deny their use if integrity verification fails. IPE generates audit logs which may be utilized to detect integrity verification failures. Tampering threat scenarios include modification or replacement of executable code by a range of actors including: Insiders with physical access to the hardware Insiders with local network access to the system Insiders with access to the deployment system Compromised internal systems under external control Malicious end users of the system Compromised end users of the system Remote (external) compromise of the system IPE does not mitigate threats arising from malicious authorized developers, or compromised developer tools used by authorized developers. Additionally, IPE draws hard security boundary between user mode and kernel mode. As a result, IPE does not provide any protections against a kernel level exploit, and a kernel-level exploit can disable or tamper with IPE's protections. The root of trust for all of IPE's verifications is the SYSTEM_TRUSTED_KEYRING of the Linux kernel, which is a set of keys that are provisioned at kernel build-time.","title":"Threat Model"},{"location":"technical/threat-model/#threat-model","text":"The threat type addressed by IPE is tampering of executable user-land code beyond the initially booted kernel, and the initial verification of kernel modules that are loaded in userland through modprobe or insmod . Tampering violates the property of integrity. IPE's role in mitigating this threat is to verify the integrity (and authenticity) of all executable code and to deny their use if integrity verification fails. IPE generates audit logs which may be utilized to detect integrity verification failures. Tampering threat scenarios include modification or replacement of executable code by a range of actors including: Insiders with physical access to the hardware Insiders with local network access to the system Insiders with access to the deployment system Compromised internal systems under external control Malicious end users of the system Compromised end users of the system Remote (external) compromise of the system IPE does not mitigate threats arising from malicious authorized developers, or compromised developer tools used by authorized developers. Additionally, IPE draws hard security boundary between user mode and kernel mode. As a result, IPE does not provide any protections against a kernel level exploit, and a kernel-level exploit can disable or tamper with IPE's protections. The root of trust for all of IPE's verifications is the SYSTEM_TRUSTED_KEYRING of the Linux kernel, which is a set of keys that are provisioned at kernel build-time.","title":"Threat Model"}]}